Vamos a empezar creando el archivo que servirá de columna vertebral para todo el proyecto: `includes/minishell.h`.

### **Fase 1.1: Definiciones Globales (Parte 1: Librerías)**

El objetivo de este archivo es centralizar todas las librerías necesarias y las estructuras de datos que compartirán todos tus archivos `.c`. Así evitamos tener que incluir `stdio.h` o definir `struct s_shell` veinte veces.

Abre (o crea) el archivo `includes/minishell.h` y escribe el siguiente bloque inicial.

```c
#ifndef MINISHELL_H
# define MINISHELL_H

# include <errno.h>
# include <fcntl.h>
# include <signal.h>
# include <stddef.h>
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <sys/stat.h>
# include <sys/types.h>
# include <sys/wait.h>
# include <termios.h>
# include <unistd.h>
# include <limits.h>

/* readline */
# include <readline/history.h>
# include <readline/readline.h>

/* libft */
# include <libft.h>
```

#### **Explicación línea a línea:**

1.  **`#ifndef MINISHELL_H` y `# define MINISHELL_H`**:

      * [cite\_start]**Qué son:** Son "Include Guards" (Guardas de inclusión)[cite: 632].
      * **Por qué:** Imagina que el archivo `parser.c` incluye `minishell.h`, y `main.c` también lo incluye. Si no tuviéramos esto, el compilador intentaría copiar el contenido dos veces, generando errores de "redefinición". Estas líneas aseguran que el contenido se procese una sola vez.

2.  [cite\_start]**Librerías del Sistema (Standard Libs)**[cite: 632]:

      * **`<unistd.h>`:** Es la más importante en este proyecto. Nos da acceso a la API POSIX del sistema operativo: `fork` (crear procesos), `execve` (ejecutar programas), `write`, `read`, `getcwd`, etc.
      * **`<stdio.h>`:** Para `printf` y `perror`. Aunque en 42 solemos usar `ft_printf`, `perror` es muy útil para imprimir errores del sistema.
      * **`<stdlib.h>`:** Para `malloc`, `free` y `exit`. Gestión de memoria y salida del programa.
      * **`<signal.h>`:** Necesaria para `signal` o `sigaction`. Aquí definiremos cómo reacciona el shell a `Ctrl+C`.
      * **`<sys/wait.h>`:** Contiene `wait` y `waitpid`. Imprescindible para que el proceso padre (tu shell) espere a que el hijo (el comando `ls`) termine.
      * **`<fcntl.h>`:** Para `open`. Define las flags como `O_RDONLY`, `O_TRUNC`, etc., necesarias para las redirecciones (`>`, `<`).
      * **`<termios.h>`:** Nos permite manipular la configuración de la terminal (por ejemplo, para ocultar caracteres de control como `^C`).
      * **`<errno.h>`:** Nos da acceso a la variable global `errno`, que nos dice *por qué* falló una función del sistema (ej: "Permiso denegado").

3.  [cite\_start]**Readline**[cite: 632]:

      * **`<readline/readline.h>`:** Proporciona la función `readline("prompt> ")`, que maneja la entrada del usuario y la edición de línea (flechas, borrar, etc.).
      * **`<readline/history.h>`:** Permite usar `add_history`, para que al pulsar la flecha arriba recuerdes comandos anteriores.

4.  [cite\_start]**Libft**[cite: 632]:

      * **`<libft.h>`:** Tu librería personal. La usaremos extensivamente para manipular strings (`ft_split`, `ft_strdup`) y listas.

-----

**Paso siguiente:**
Una vez tengas copiadas estas librerías en tu header, avísame. El siguiente paso será definir las **Estructuras de Datos (Structs)** justo debajo de esos includes, que es donde definiremos qué es un "Comando" y qué es la "Shell".

¿Listo para definir los structs?