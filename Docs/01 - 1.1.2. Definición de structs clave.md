¬°Genial\! Vamos a continuar con la **Fase 1.1**. Ya tienes las librer√≠as, ahora necesitamos definir los "planos" de tus datos.

En C, como no tenemos clases (como en Java o C++), usamos `structs` para organizar la informaci√≥n. Tu Minishell tiene una jerarqu√≠a de datos muy clara:

`Shell` contiene -\> `Pipeline` contiene -\> `Comandos` contienen -\> `Redirecciones` y `Argumentos`.

Copia el siguiente c√≥digo en tu archivo `includes/minishell.h`, justo **debajo** de los `#include` y **antes** del `#endif`.

```c
typedef struct s_redir
{
	int			type;
	char		*target;
}	t_redir;

typedef struct s_cmd
{
	char		**argv;
	t_redir		*redirs;
	int			redir_count;
}	t_cmd;

typedef struct s_pipeline
{
	t_cmd		*commands;
	int			count;
}	t_pipeline;

typedef struct s_shell
{
	char			**envp;
	int				last_status;
	int				running;
	t_pipeline		*current_pipeline;
	char			*current_line;
	char			**current_segments;
	struct termios	term_orig;
	int				term_saved;
}	t_shell;

/* Contextos auxiliares (usados m√°s adelante) */
typedef struct s_parse_ctx
{
	t_cmd	*cmd;
	int		i;
	int		j;
	int		cap;
	int		quoted;
}	t_parse_ctx;

typedef struct s_tok_ctx
{
	const char	*line;
	int			i;
	int			n;
	int			has_space;
}	t_tok_ctx;

typedef struct s_pipe_ctx
{
	int		i;
	int		fd_in;
	int		pipefd[2];
	pid_t	last_pid;
}	t_pipe_ctx;
```

-----

### üîç Explicaci√≥n paso a paso de tus Estructuras

[cite\_start]Aqu√≠ es donde se define la l√≥gica de tu programa[cite: 632]:

1.  **`t_redir` (Redirecci√≥n individual):**

      * Representa cosas como `> archivo.txt` o `< input`.
      * `int type`: Un n√∫mero que nos dir√° qu√© s√≠mbolo es (0 para `<`, 1 para `>`, etc.).
      * `char *target`: El nombre del archivo al que redirigimos (ej: "archivo.txt").

2.  **`t_cmd` (Comando simple):**

      * Es la unidad b√°sica de ejecuci√≥n.
      * `char **argv`: La lista de argumentos que pasaremos a `execve`. Ejemplo: `{"ls", "-l", NULL}`.
      * `t_redir *redirs`: Un array din√°mico con todas las redirecciones de este comando.
      * *Nota:* Es importante separar `argv` de `redirs` porque `execve` no entiende de redirecciones; eso lo tiene que gestionar la shell antes.

3.  **`t_pipeline` (L√≠nea de tuber√≠as):**

      * Representa una secuencia de comandos conectados por `|`.
      * `t_cmd *commands`: Un array de comandos. Si escribes `ls | grep a | wc -l`, aqu√≠ habr√° 3 `t_cmd`.
      * `int count`: Cu√°ntos comandos hay en total (para saber cu√°ndo parar los bucles).

4.  **`t_shell` (El Estado Global):**

      * Esta es la estructura "maestra" que pasaremos a casi todas las funciones.
      * `char **envp`: Nuestra copia local de las variables de entorno (`PATH`, `USER`, etc.).
      * `int last_status`: Aqu√≠ guardaremos el `$?` (el c√≥digo de salida del √∫ltimo comando ejecutado).
      * `int running`: Un "interruptor" (1 o 0). Si se pone a 0, el bucle principal del shell se rompe y el programa termina (comando `exit`).
      * `current_line`, `current_pipeline`, etc.: Punteros para limpiar memoria f√°cilmente si hay un error o una se√±al (`Ctrl+C`).
      * `struct termios term_orig`: Para guardar la configuraci√≥n original de la terminal y poder restaurarla al salir (evita que la terminal se rompa al cerrar minishell).

5.  **Estructuras `_ctx` (Contextos):**

      * `t_parse_ctx`, `t_tok_ctx`, `t_pipe_ctx`: Son estructuras de ayuda ("helpers") para funciones complejas. En lugar de pasar 10 variables como argumentos a una funci√≥n, pasamos una sola estructura de contexto. Esto ayuda a cumplir la Norma (m√°ximo 4 argumentos por funci√≥n) y mantiene el c√≥digo limpio.

-----

### ‚úÖ Siguiente Paso

Ahora que tenemos los **datos** definidos, necesitamos las herramientas para gestionarlos de forma segura.

Vamos a la **Fase 1.2: Gesti√≥n de Memoria Segura**. Crearemos el archivo `src/utils/memory_utils.c` para no tener que comprobar si `malloc` devuelve NULL cada vez que lo usamos.

¬øPreparado para crear el primer archivo `.c`?