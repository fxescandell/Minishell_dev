### **1.2.2. Función `free_string_array` para matrices `char **`**

En Minishell trabajarás constantemente con listas de cadenas de texto, como los argumentos de un comando (`{"ls", "-l", NULL}`) o las variables de entorno. Estas estructuras son de tipo `char **` (un puntero a punteros). Limpiar su memoria correctamente requiere un proceso cuidadoso de dos pasos.

Añade esta función debajo de `safe_malloc` en tu archivo `src/utils/memory_utils.c`:

```c
void	free_string_array(char **array)
{
	int	i;

	if (!array)
		return ;
	i = 0;
	while (array[i])
	{
		free(array[i]);
		i++;
	}
	free(array);
}
```

#### **Explicación línea a línea:**

1.  `if (!array) return ;`:

      * **Protección:** Si nos pasan una lista que no existe (`NULL`), no hacemos nada. Intentar acceder a `array[i]` si `array` es `NULL` causaría un crash inmediato.

2.  `while (array[i])`:

      * Asumimos (por convención en C y en POSIX) que estas listas de cadenas siempre terminan con un puntero `NULL` al final. El bucle recorre la lista hasta encontrar ese terminador.

3.  `free(array[i]);`:

      * **Paso 1 (El contenido):** Liberamos cada cadena individualmente.
      * Imagina una estantería con cajas. Primero tienes que tirar las cajas a la basura una por una.

4.  `free(array);`:

      * **Paso 2 (El contenedor):** Una vez las cadenas internas han desaparecido, liberamos el array principal que contenía los punteros.
      * **¿Por qué el orden importa?** Si liberaras `array` primero, perderías la dirección de memoria de las cadenas (`array[0]`, `array[1]`, etc.) y ya nunca podrías borrarlas, causando una fuga de memoria (Memory Leak).

-----

Con esto terminamos el punto **1.2**. Hemos creado herramientas robustas para crear y destruir datos.