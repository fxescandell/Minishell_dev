춰Genial\! Avanzamos al punto final de esta fase de c칩digo C.

Estamos en **1.5.2. Funci칩n `main` m칤nima**.

**Objetivo:**
Implementar el punto de entrada del programa. Aqu칤 conectaremos la inicializaci칩n (que acabamos de hacer) con la limpieza (que hicimos antes).

Como todav칤a no hemos creado el **Bucle Principal** (Fase 2) ni el sistema de **Se침ales** (Fase 10), dejaremos esas llamadas comentadas para que podamos compilar y probar que la infraestructura b치sica funciona sin errores.

A침ade esta funci칩n al final de tu archivo `src/main.c`:

```c
int	main(int argc, char **argv, char **envp)
{
	t_shell	shell;

	(void)argc;
	(void)argv;
	/* Ignorar SIGPIPE evita que el shell muera si un pipe falla */
	signal(SIGPIPE, SIG_IGN);
	
	init_shell(&shell, envp);
	
	/* Pendiente Fase 10: Configurar se침ales interactivas (Ctrl+C)
	setup_interactive_signals(); 
	*/

	/* Pendiente Fase 2: Bucle principal
	run_shell_loop(&shell);
	*/

	cleanup_shell(&shell);
	return (shell.last_status);
}
```

[cite\_start][cite: 32, 41]

#### **游댌 Explicaci칩n detallada l칤nea a l칤nea:**

1.  **`t_shell shell;`**:

      * Declaramos nuestra estructura principal en la **pila (stack)** del `main`.
      * Esto significa que la memoria de la estructura en s칤 (los punteros que contiene) se gestiona autom치ticamente. Lo que gestionaremos manualmente es la memoria a la que *apuntan* esos punteros (`envp`, `current_line`, etc.).

2.  **`(void)argc; (void)argv;`**:

      * Minishell (en su parte obligatoria) no suele recibir argumentos (como `bash -c "comando"`). [cite\_start]Estas l칤neas evitan que el compilador se queje con un *warning* de "unused parameter"[cite: 41].

3.  **`signal(SIGPIPE, SIG_IGN);`**:

      * **Concepto de sistema:** Cuando escribes en un pipe (`|`) y el proceso que lee se cierra inesperadamente, el sistema env칤a una se침al `SIGPIPE` que mata al proceso escritor por defecto.
      * Al ponerla en `SIG_IGN` (ignorar), evitamos que tu shell explote si falla un pipe.

4.  **`init_shell(&shell, envp);`**:

      * Llamamos a la funci칩n que escribiste en el paso 1.5.1. Pasamos la direcci칩n de `shell` (`&shell`) para que la funci칩n pueda modificar sus valores a cero/NULL.

5.  **Partes Comentadas (`setup_interactive_signals`, `run_shell_loop`)**:

      * Estas funciones son el "coraz칩n" y el "sistema nervioso" del shell. Como a칰n no existen los archivos `.c` donde se definen, si las descomentamos ahora, el compilador nos dar칤a un error de "undefined reference" (referencia no definida).
      * Las descomentaremos en la Fase 10 y la Fase 2 respectivamente.

6.  **`cleanup_shell(&shell);`**:

      * Antes de salir, limpiamos todo. Incluso si el bucle no se ha ejecutado, esta funci칩n asegura que la terminal se restaure si fuera necesario.

7.  **`return (shell.last_status);`**:

      * Devolvemos al sistema operativo el c칩digo de salida del 칰ltimo comando ejecutado.

-----

춰Hemos terminado de escribir todo el c칩digo C de la Fase 1\! 游꿀

Ahora necesitamos el "manual de instrucciones" para que el compilador (`cc`) sepa c칩mo convertir estos archivos en un ejecutable.
