### **1.6.1. Contenido del Makefile (Fase 1)**

```makefile
NAME        := minishell
CC          := cc
CFLAGS      := -Wall -Wextra -Werror -g
INCLUDES    := -Iincludes

SRC_DIR     := src
OBJ_DIR     := obj

# --- Colores y EstÃ©tica (Opcional pero Ãºtil para ver errores) ---
GREEN       := \033[0;92m
CYAN        := \033[0;96m
DEF_COLOR   := \033[0;39m

# --- DetecciÃ³n del Sistema Operativo (Para Readline) ---
UNAME_S := $(shell uname -s)
ifeq ($(UNAME_S),Linux)
    # En Linux, readline suele estar en las rutas estÃ¡ndar
    READLINE_LIB := -lreadline
else
    # En macOS (42), solemos usar brew. Hay que buscar dÃ³nde estÃ¡.
    READLINE_INC := -I$(shell brew --prefix readline)/include
    READLINE_LIB := -L$(shell brew --prefix readline)/lib -lreadline
endif

# --- Libft (Asumimos que tienes tu libft en la carpeta libft) ---
LIBFT_DIR := libft
LIBFT     := $(LIBFT_DIR)/libft.a
LIBFT_INC := -I$(LIBFT_DIR)/include

# --- Archivos Fuente (SOLO LOS QUE TENEMOS AHORA) ---
SRC :=  $(SRC_DIR)/main.c \
        $(SRC_DIR)/shell_cleanup.c \
        $(SRC_DIR)/utils/memory_utils.c \
        $(SRC_DIR)/utils/error_utils.c

# --- TransformaciÃ³n de rutas (.c -> .o) ---
OBJ := $(SRC:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)

# --- Reglas ---

all: $(NAME)

# Crear el ejecutable
$(NAME): $(LIBFT) $(OBJ)
	@printf "\n"
	@$(CC) $(CFLAGS) $(OBJ) $(LIBFT) $(READLINE_LIB) -o $(NAME)
	@echo "$(GREEN) âœ“ Minishell compiled successfully!$(DEF_COLOR)"

# Compilar la librerÃ­a Libft
$(LIBFT):
	@$(MAKE) -C $(LIBFT_DIR)

# Compilar objetos individuales (.c -> .o)
# Se asegura de crear la carpeta obj/ si no existe
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c Makefile
	@mkdir -p $(dir $@)
	@printf "$(CYAN)Compiling: $< $(DEF_COLOR)\r"
	@$(CC) $(CFLAGS) $(INCLUDES) $(READLINE_INC) $(LIBFT_INC) -c $< -o $@

# Limpieza
clean:
	@rm -rf $(OBJ_DIR)
	@$(MAKE) -C $(LIBFT_DIR) clean
	@echo " â— Minishell build directory removed."

fclean: clean
	@rm -f $(NAME)
	@$(MAKE) -C $(LIBFT_DIR) fclean

re: fclean all

.PHONY: all clean fclean re
```

[cite\_start][cite: 1]

#### **ðŸ” ExplicaciÃ³n detallada lÃ­nea a lÃ­nea:**

1.  **Variables y Flags:**

      * `CC = cc`: El compilador estÃ¡ndar.
      * `CFLAGS = -Wall -Wextra -Werror -g`: Las banderas sagradas de 42. He aÃ±adido `-g` para que puedas depurar con `valgrind` o `gdb` si hay errores (fase de debug).
      * `INCLUDES`: Le dice al compilador dÃ³nde buscar tus archivos `.h` (`-Iincludes`).

2.  **DetecciÃ³n de `readline`**:

      * `UNAME_S := $(shell uname -s)`: Ejecuta el comando de terminal `uname -s` para saber si estÃ¡s en "Linux" o "Darwin" (macOS).
      * **Linux:** `readline` suele venir instalado en el sistema, asÃ­ que basta con `-lreadline`.
      * **macOS (Brew):** `readline` no viene por defecto o es antigua. Usamos `brew --prefix readline` para encontrar dÃ³nde la instalÃ³ Homebrew y aÃ±adimos manualmente las rutas de los *headers* (`-I`) y las librerÃ­as (`-L`). [cite\_start]Esto es vital para que compile en los Macs de la escuela[cite: 1].

3.  **Regla `$(OBJ_DIR)/%.o` (PatrÃ³n)**:

      * Esta es la magia. Dice: "Para crear cualquier archivo `.o` dentro de la carpeta `obj`, busca su correspondiente `.c` en `src`".
      * `mkdir -p $(dir $@)`: Crea automÃ¡ticamente la estructura de carpetas dentro de `obj/` (por ejemplo `obj/utils/`) para que no dÃ© error al guardar el `.o`.

4.  **Linkado final `$(NAME)`**:

      * `$(CC) $(CFLAGS) $(OBJ) $(LIBFT) $(READLINE_LIB) -o $(NAME)`:
      * Junta tus objetos (`main.o`, `memory_utils.o`...) + tu librerÃ­a `libft.a` + la librerÃ­a dinÃ¡mica `readline`. El resultado es el ejecutable `minishell`.

-----

### ðŸ§ª **Prueba de la Fase 1**

Ahora viene el momento de la verdad. Hemos escrito mucha infraestructura. Vamos a ver si funciona.

1.  AsegÃºrate de tener tu `libft` en la carpeta `libft/` (con su propio Makefile).

2.  Ejecuta en la terminal:

    ```bash
    make
    ```

3.  Si todo va bien, verÃ¡s mensajes de compilaciÃ³n y finalmente `âœ“ Minishell compiled successfully!`.

4.  Ejecuta el programa:

    ```bash
    ./minishell
    ```

      * **Resultado esperado:** El programa debe arrancar y terminar inmediatamente (quizÃ¡s imprima un error de `readline` si no hay terminal, o simplemente nada porque comentamos el bucle).
      * Comprueba el retorno: `echo $?` deberÃ­a dar `0`.

5.  Prueba con Valgrind (si estÃ¡s en Linux):

    ```bash
    valgrind ./minishell
    ```

      * **Resultado esperado:** "All heap blocks were freed -- no leaks are possible". Gracias a tu `cleanup_shell`.

Â¿Te ha compilado correctamente? Si es asÃ­, Â¡felicidades\! Has completado la **Fase 1**. Tenemos un esqueleto robusto, gestiÃ³n de memoria y sistema de compilaciÃ³n. ðŸŽ‰