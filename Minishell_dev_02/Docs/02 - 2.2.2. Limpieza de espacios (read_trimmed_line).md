Continuamos con el punto **2.2.2. Limpieza de espacios (`read_trimmed_line`)**.

**Objetivo:**
Cuando leemos desde una tuber칤a o un archivo (modo no interactivo), necesitamos una funci칩n que obtenga la l칤nea cruda y la "limpie". Normalmente, las funciones de lectura (como `getline` o `read`) incluyen el salto de l칤nea (`\n`) al final. Para que el parser funcione bien, debemos eliminar ese salto de l칤nea y convertirlo en un terminador nulo (`\0`).

Adem치s, esta funci칩n delegar치 la tarea pesada de gesti칩n de memoria a `ft_getline_internal` (que veremos m치s adelante en un archivo separado), manteniendo este archivo limpio.

**Instrucci칩n:**
Vuelve a abrir `src/loop_io.c`. Debes insertar la siguiente funci칩n **encima** de `process_line` (donde dejamos el hueco en el paso anterior).

```c
int	read_trimmed_line(char **buf, size_t *cap)
{
	ssize_t	r;

	r = ft_getline_internal(buf, cap);
	if (r <= 0)
		return (0);
	if (r > 0 && (*buf)[r - 1] == '\n')
		(*buf)[r - 1] = '\0';
	return (1);
}
```

[cite\_start][cite: 210-212]

#### **游댌 Explicaci칩n detallada l칤nea a l칤nea:**

1.  **`int read_trimmed_line(char **buf, size_t *cap)`**:

      * Recibe un puntero al buffer (`buf`) y a su capacidad (`cap`). Esto permite reutilizar la memoria del buffer entre lecturas para ser m치s eficientes, en lugar de hacer `malloc` y `free` constantemente.
      * Devuelve `1` si ley칩 una l칤nea correctamente, o `0` si hubo error o fin de archivo (EOF).

2.  **`r = ft_getline_internal(buf, cap);`**:

      * Llamamos a nuestra funci칩n interna (que implementaremos en `src/loop_io_getline.c`).
      * Esta funci칩n se encarga de leer byte a byte y redimensionar el buffer si la l칤nea es muy larga.
      * Devuelve el n칰mero de caracteres le칤dos (`r`).

3.  **`if (r <= 0) return (0);`**:

      * Si `r` es 0 (EOF) o negativo (error), indicamos que no se pudo leer ninguna l칤nea v치lida.

4.  **`if (r > 0 && (*buf)[r - 1] == '\n')`**:

      * Verificamos si el 칰ltimo car치cter le칤do es un salto de l칤nea.

5.  **`(*buf)[r - 1] = '\0';`**:

      * **La limpieza:** Sobrescribimos el `\n` con `\0`.
      * *Ejemplo:* Si el archivo ten칤a `hola\n`, ahora en memoria tenemos `hola\0`. Esto es crucial porque `tokenize` o `printf` no esperan saltos de l칤nea al final de un comando.

-----

Ahora `src/loop_io.c` tiene la capacidad de procesar l칤neas y de leerlas de forma limpia. Pero todav칤a nos falta la utilidad para saber si una l칤nea est치 vac칤a y la l칩gica de separaci칩n de comandos.
