### **2.3.1. L칩gica para separar comandos por `;` sin romper comillas**

Vamos a construir este archivo paso a paso, empezando por la l칩gica de detecci칩n de comillas.

Crea el archivo `src/loop_io_split.c` e incluye las cabeceras:

```c
#include "loop_io.h"
#include "minishell.h"
```

#### **Paso A: El Detector de Estado (`is_unquoted_semicolon`)**

Esta funci칩n auxiliar nos dice si un `;` en una posici칩n concreta es un separador real o solo texto.

A침ade esto a `src/loop_io_split.c`:

```c
static int	is_unquoted_semicolon(const char *s, int pos)
{
	int	i;
	int	in_single;
	int	in_double;

	i = 0;
	in_single = 0;
	in_double = 0;
	while (i < pos)
	{
		if (s[i] == '\'' && !in_double)
			in_single = !in_single;
		else if (s[i] == '"' && !in_single)
			in_double = !in_double;
		else if (s[i] == '\\' && s[i + 1] != '\0')
			i++;
		i++;
	}
	return (s[pos] == ';' && !in_single && !in_double);
}
```

[cite\_start][cite: 88-90]

**游댌 Explicaci칩n detallada:**

1.  **Variables de Estado (`in_single`, `in_double`)**:

      * Act칰an como interruptores (0 o 1). Si `in_single` es 1, estamos dentro de comillas simples `'`.

2.  **El Bucle `while (i < pos)`**:

      * Recorremos la cadena desde el principio hasta llegar justo antes del car치cter que queremos comprobar (`pos`). Necesitamos leer desde el principio para saber el contexto.

3.  **`if (s[i] == '\'' && !in_double)`**:

      * Si encontramos una comilla simple `'` y **no** estamos dentro de comillas dobles, invertimos el estado de `in_single`. (Si estaba cerrado, se abre; si estaba abierto, se cierra).
      * *Nota:* Si estamos en dobles (`"hola ' amigo"`), la comilla simple es solo un car치cter m치s, por eso la condici칩n `!in_double`.

4.  **`else if (s[i] == '\\' ...)`**:

      * Manejo b치sico de escapes. Si vemos una barra invertida `\`, saltamos el siguiente car치cter (`i++`), porque ese siguiente car치cter es literal y no debe interpretarse como comilla.

5.  **`return (...)`**:

      * Solo devolvemos verdadero (1) si el car치cter en `pos` es un `;` **Y** ambos interruptores de comillas est치n apagados (0).

-----

#### **Paso B: Contar y Rellenar (`count` & `fill`)**

Ahora que sabemos identificar los separadores reales, necesitamos dos funciones: una para saber cu치nta memoria reservar y otra para copiar los trozos.

A침ade estas funciones debajo de la anterior:

```c
static int	count_semicolons(const char *line)
{
	int	count;
	int	i;

	count = 1;
	i = 0;
	while (line[i])
	{
		if (is_unquoted_semicolon(line, i))
			count++;
		i++;
	}
	return (count);
}

static void	fill_segments(char **result, const char *line)
{
	int	i;
	int	start;
	int	j;

	i = 0;
	start = 0;
	j = 0;
	while (line[i])
	{
		if (is_unquoted_semicolon(line, i))
			{
				result[j++] = ft_substr(line, start, i - start);
				start = i + 1;
			}
		i++;
	}
	result[j++] = ft_substr(line, start, i - start);
	result[j] = NULL;
}
```

**游댌 Explicaci칩n r치pida:**

  * **`count_semicolons`**: Empieza en 1 (porque si no hay `;`, hay al menos 1 comando). Cada vez que encuentra un `;` v치lido, suma 1.
  * **`fill_segments`**:
      * `start`: Marca d칩nde empez칩 el comando actual.
      * Cuando encuentra un `;` v치lido en `i`:
          * Corta el string desde `start` hasta `i` usando `ft_substr` (de tu libft).
          * Guarda ese trozo en el array `result`.
          * Actualiza `start` a `i + 1` (salt치ndose el punto y coma).
      * Al final del bucle, guarda el 칰ltimo trozo (lo que queda despu칠s del 칰ltimo `;`) y pone el `NULL` final.

-----

#### **Paso C: La Funci칩n Principal (`split_by_semicolon`)**

Finalmente, la funci칩n p칰blica que orquesta todo.

A침치dela al final del archivo:

```c
char	**split_by_semicolon(const char *line)
{
	char	**result;
	int		count;

	count = count_semicolons(line);
	result = (char **)safe_malloc(sizeof(char *) * (count + 1));
	fill_segments(result, line);
	return (result);
}
```

**游댌 Explicaci칩n:**

1.  Calcula el tama침o necesario.
2.  Usa `safe_malloc` (nuestra herramienta de la Fase 1) para reservar el array de punteros.
3.  Llama a `fill` para hacer el trabajo sucio y devuelve el resultado limpio.

-----

춰Hecho\! Ahora tu shell es capaz de entender la diferencia entre:

  * `echo a; echo b` -\> Dos comandos.
  * `echo "a; b"` -\> Un solo comando.

쯇asamos al **2.4. Bucles de Ejecuci칩n** para conectar todo esto y hacer que el shell funcione de verdad?