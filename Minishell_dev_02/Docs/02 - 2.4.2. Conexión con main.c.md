Estamos en el punto **2.4.2. Conexi칩n con `main.c`**.

**Objetivo:**
Tenemos el bucle interactivo (`run_tty_loop`) listo, pero el `main` todav칤a no sabe c칩mo llamarlo. Adem치s, un buen shell debe saber distinguir si lo est치 ejecutando un humano (teclado) o una m치quina (un script o un pipe).

Necesitamos un "Dispatcher" (intermediario) en `src/loop.c` que tome esa decisi칩n y luego conectarlo todo en `src/main.c`.

-----

### **Paso A: El Despachador (`src/loop.c`)**

Este archivo decidir치 qu칠 modo ejecutar.

Crea el archivo `src/loop.c` y a침ade el siguiente c칩digo:

```c
#include "loop.h"
#include "loop_io.h"

/* Pendiente: Definiremos esto bien en el futuro si ampliamos a scripts.
   Por ahora necesitamos que exista para que el c칩digo compile. */
void	run_non_tty_loop(t_shell *sh)
{
	(void)sh;
	// En el futuro aqu칤 ir치 la l칩gica para leer de pipes/archivos
}

void	run_shell_loop(t_shell *shell)
{
	/* 1. Detectar si somos interactivos */
	if (!isatty(STDIN_FILENO))
	{
		run_non_tty_loop(shell);
		return ;
	}

	/* 2. Modo Interactivo: Mostrar intro y arrancar */
	show_msx_intro();
	run_tty_loop(shell);
}
```

[cite\_start][cite: 187-188]

#### **游댌 Explicaci칩n detallada:**

1.  **`if (!isatty(STDIN_FILENO))`**:

      * `isatty` comprueba si la entrada est치ndar est치 conectada a una terminal.
      * Si devuelve `0` (falso), significa que nos est치n pasando datos por una tuber칤a (ej: `echo "ls" | ./minishell`). En ese caso, **no** debemos mostrar el prompt ` MSX>  ` ni la bienvenida, o romper칤amos la salida del script.

2.  **`show_msx_intro()`**:

      * Si es una terminal real, mostramos tu banner retro antes de empezar.

3.  **`run_tty_loop(shell)`**:

      * Lanzamos el bucle infinito que creaste en el paso anterior.

4.  **`run_non_tty_loop` (Stub)**:

      * He incluido una versi칩n vac칤a de esta funci칩n aqu칤 mismo (o podr칤as ponerla en `src/loop_non_tty.c`). Es necesaria porque `loop.h` dice que existe, y si no la definimos, el compilador (`make`) dar치 un error de "undefined reference".

-----

### **Paso B: Actualizar el `main` (`src/main.c`)**

Ahora que tenemos el motor listo, vamos a encenderlo.

Abre `src/main.c`. Tienes que hacer dos cambios:

1.  Incluir el header `loop.h` al principio.
2.  Descomentar la llamada a `run_shell_loop` en la funci칩n `main`.

Tu `src/main.c` deber칤a quedar as칤 (resumido):

```c
#include "minishell.h"
#include "loop.h"  /* <--- 1. A칌ADIR ESTO */

/* ... (funciones init_terminal e init_shell siguen igual) ... */

int	main(int argc, char **argv, char **envp)
{
	t_shell	shell;

	(void)argc;
	(void)argv;
	signal(SIGPIPE, SIG_IGN);
	
	init_shell(&shell, envp);
	
	/* Pendiente Fase 10: setup_interactive_signals(); */

	run_shell_loop(&shell); /* <--- 2. DESCOMENTAR ESTO */

	cleanup_shell(&shell);
	return (shell.last_status);
}
```

[cite\_start][cite: 182]

-----

### **Paso C: Actualizar `Makefile`**

Para que esto compile, necesitamos a침adir los nuevos archivos `.c` a la lista `SRC` en tu `Makefile`.

Abre el `Makefile` y actualiza la variable `SRC` para incluir los archivos de la Fase 2:

```makefile
SRC :=  $(SRC_DIR)/main.c \
        $(SRC_DIR)/shell_cleanup.c \
        $(SRC_DIR)/utils/memory_utils.c \
        $(SRC_DIR)/utils/error_utils.c \
        $(SRC_DIR)/msx_ui.c \
        $(SRC_DIR)/loop_io.c \
        $(SRC_DIR)/loop_io_split.c \
        $(SRC_DIR)/loop_tty.c \
        $(SRC_DIR)/loop.c \
        $(SRC_DIR)/loop_io_getline.c  # (Si creaste este archivo en 2.2.2, si no, qu칤talo por ahora)
```

*Nota:* En el paso 2.2.2 mencionamos `ft_getline_internal`. Si no creaste el archivo `src/loop_io_getline.c` todav칤a, el compilador se quejar치.

  * [cite\_start]**Opci칩n r치pida:** Crea `src/loop_io_getline.c` y pega la funci칩n `ft_getline_internal` de tu c칩digo original [cite: 243-246] O usa `get_next_line` de tu `libft` si la tienes.
  * **Para seguir tu c칩digo estricto:** Deber칤amos crear `src/loop_io_getline.c`. 쯈uieres que hagamos ese archivo r치pidamente antes de probar, o asumo que usas `get_next_line`?

(Asumiendo que quieres seguir tu c칩digo exacto, te doy el contenido de `src/loop_io_getline.c` aqu칤 mismo para completar la fase):

**Archivo Extra: `src/loop_io_getline.c`**

```c
#include "loop_io.h"
#include "minishell.h"

/* Versi칩n simplificada basada en tu c칩digo */
ssize_t	ft_getline_internal(char **buf, size_t *cap)
{
    /* Por ahora, para testear, puedes usar get_next_line o una implementaci칩n simple.
       Tu c칩digo original tiene una implementaci칩n robusta de realloc.
       Si quieres probar YA, puedes hacer que devuelva 0 para no bloquear,
       pero lo ideal es copiar tu implementaci칩n original. */
    return (0); // Placeholder para que compile si no tienes la implementaci칩n a mano
}
```

*Mejor a칰n: Si tienes tu `libft` linkeada y funciona, el paso 2.2.2 usaba `ft_getline_internal`. Si ese archivo no existe, dar치 error de linkado.*

-----

### 游빍 **Prueba de la Fase 2**

1.  Ejecuta `make`.
2.  Ejecuta `./minishell`.

**Deber칤as ver:**

```text
MSX BASIC version 1.0
Copyright 1983 by Mocosoft
32559 Bytes free

Ready

MSX> 
```

춰Y deber칤as poder escribir\!

  * Prueba escribir `hola; mundo`.
  * (No har치 nada "visible" excepto guardarlo en el historial y procesarlo internamente, porque `process_segments_array` todav칤a no ejecuta nada real, pero **no debe fallar**).
  * Prueba `Ctrl+D`: Deber칤a salir limpiamente mostrando "exit".

쮽unciona el prompt y la lectura? 춰Si es as칤, hemos completado la **Fase 2**\! 游꿀
