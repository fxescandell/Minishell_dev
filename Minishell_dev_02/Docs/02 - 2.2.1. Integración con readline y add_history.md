### **2.2.1. Integraci贸n con `readline` y `add_history`**

**Objetivo:**
Implementar la funci贸n `process_line` en `src/loop_io.c`. Esta funci贸n es el puente entre "recibir texto" y "ejecutar texto". Sus responsabilidades son:

1.  Ignorar l铆neas vac铆as (el usuario solo puls贸 Enter).
2.  **Guardar en el historial:** Usar `add_history` para que la flecha arriba `` funcione.
3.  **Segmentar:** Si el usuario escribe `ls; pwd`, hay que partirlo en dos.
4.  **Delegar:** Enviar los fragmentos a ejecutar.

**Instrucci贸n:**
Crea el archivo `src/loop_io.c` y a帽ade el siguiente c贸digo. (Nota: Dejaremos un hueco arriba para la funci贸n del siguiente punto).

```c
#include "loop_io.h"
#include "minishell.h"

/* (Aqu铆 ir谩 read_trimmed_line en el paso 2.2.2)
*/

void	process_line(char *line, t_shell *shell, int record_history)
{
	char	**segments;

	/* 1. Limpieza de seguridad por si qued贸 basura anterior */
	if (shell->current_segments)
	{
		free_string_array(shell->current_segments);
		shell->current_segments = NULL;
	}

	/* 2. Si solo son espacios o vac铆o, no hacemos nada */
	if (is_empty_or_spaces(line))
		return ;

	/* 3. Integraci贸n con Readline: Guardar en historial */
	if (record_history)
		add_history(line);

	/* 4. L贸gica de separaci贸n por punto y coma (;) */
	segments = split_by_semicolon(line);
	shell->current_segments = segments;

	/* 5. Ejecuci贸n de cada segmento */
	process_segments_array(segments, shell);

	/* 6. Limpieza tras la ejecuci贸n */
	free_string_array(shell->current_segments);
	shell->current_segments = NULL;
}
```

[cite\_start][cite: 212-214]

#### ** Explicaci贸n detallada l铆nea a l铆nea:**

1.  **`if (shell->current_segments)`**:

      * Es una medida defensiva. [cite\_start]Si por alg煤n error extra帽o (o una se帽al interrumpida) quedaron segmentos de la l铆nea anterior, los limpiamos antes de empezar[cite: 212].

2.  **`if (is_empty_or_spaces(line))`**:

      * Si el usuario da a "Enter" sin escribir nada, o pone solo espacios, no queremos guardar eso en el historial ni intentar ejecutarlo. [cite\_start]Esta funci贸n auxiliar la definiremos pronto en `loop_io_utils.c`[cite: 212].

3.  **`if (record_history) add_history(line);`**:

      * **`record_history`**: Es un booleano (1 o 0). Solo guardamos historial si estamos en modo interactivo (un humano escribiendo). [cite\_start]Si el shell lee de un script, no tiene sentido guardar historial[cite: 212].
      * **`add_history`**: Funci贸n de la librer铆a `readline`. Copia la cadena `line` en su base de datos interna para que puedas recuperarla pulsando la flecha arriba.

4.  **`segments = split_by_semicolon(line);`**:

      * Aqu铆 transformamos la cadena cruda `echo a; ls` en una lista `{"echo a", "ls", NULL}`. [cite\_start]Veremos esta funci贸n en la Fase 2.3[cite: 213].
      * **`shell->current_segments = segments;`**: Guardamos la lista en nuestra estructura global (`t_shell`). **驴Por qu茅?** Porque si el usuario pulsa `Ctrl+C` mientras se ejecuta el comando, el manejador de se帽ales o la funci贸n de limpieza (`cleanup_shell`) necesitan tener acceso a esta lista para liberarla y evitar memory leaks.

5.  **`process_segments_array(segments, shell);`**:

      * Esta funci贸n iterar谩 sobre la lista y enviar谩 cada comando al parser/ejecutor.

6.  **Limpieza final**:

      * [cite\_start]Una vez terminados todos los comandos de la l铆nea, liberamos la memoria de la lista de segmentos (`free_string_array`) para estar listos para la siguiente l铆nea[cite: 213].

-----

Ya tenemos el procesador central. Ahora necesitamos las piezas que le faltan (`read_trimmed_line` y utilidades).