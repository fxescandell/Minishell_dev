### **2.1.1. Bienvenida y Prompt (` MSX>  `)**

**Objetivo:**
Definir las funciones que "pintan" la interfaz en la terminal. Queremos que al arrancar muestre un mensaje de bienvenida (estilo retro) y que use un *prompt* personalizado para pedir comandos.

Antes de escribir el c칩digo C, necesitamos definir los textos del prompt en tu cabecera para no tener "n칰meros m치gicos" (o strings m치gicos) dispersos por el c칩digo.

#### **Paso A: Definir Macros en `includes/minishell.h`**

Abre `includes/minishell.h` y a침ade estas definiciones al final del archivo, justo antes del `#endif`:

```c
# ifndef MSX_PROMPT
#  define MSX_PROMPT "MSX> "
# endif
# ifndef MSX_CONT_PROMPT
#  define MSX_CONT_PROMPT "> "
# endif
```

[cite\_start][cite: 656]

**Explicaci칩n:**

  * **`MSX_PROMPT`**: Es la cadena que `readline` imprimir치 cada vez que espere un comando.
  * **`MSX_CONT_PROMPT`**: Se usar치 si implementamos l칩gica de comandos multil칤nea (cuando un comando no termina).

-----

#### **Paso B: Implementar la UI en `src/msx_ui.c`**

Ahora, abre `src/msx_ui.c` (que creamos en el paso anterior con solo los includes) y a침ade el siguiente c칩digo:

```c
void	show_msx_intro(void)
{
	ft_printf("MSX BASIC version 1.0\n");
	ft_printf("Copyright 1983 by Mocosoft\n");
	ft_printf("32559 Bytes free\n\n");
	ft_printf("Ready\n\n");
}

char	*read_msx_line(void)
{
	return (readline(MSX_PROMPT));
}

char	*read_msx_continuation(void)
{
	return (readline(MSX_CONT_PROMPT));
}

void	handle_msx_exit(void)
{
	if (isatty(STDOUT_FILENO) && isatty(STDIN_FILENO))
		write(1, "exit\n", 5);
}
```

[cite\_start][cite: 29-31]

#### **游댌 Explicaci칩n detallada l칤nea a l칤nea:**

1.  **`void show_msx_intro(void)`**:

      * Esta funci칩n se llamar치 solo una vez al iniciar el modo interactivo.
      * **`ft_printf(...)`**: Usamos tu `libft` para imprimir el banner estilo retro. [cite\_start]Esto confirma visualmente que el shell ha arrancado correctamente[cite: 30].

2.  **`char *read_msx_line(void)`**:

      * Es un "wrapper" (envoltorio) sobre la funci칩n `readline`.
      * **`readline(MSX_PROMPT)`**:
          * Imprime ` MSX>  ` en la terminal sin salto de l칤nea.
          * Espera a que el usuario escriba y pulse Enter.
          * Devuelve una cadena (`char *`) **reservada con malloc** con lo que escribi칩 el usuario (sin el `\n` final).
          * Si el usuario pulsa `Ctrl+D` (EOF) sin escribir nada, devuelve `NULL`.

3.  **`char *read_msx_continuation(void)`**:

      * Similar a la anterior, pero usa un prompt diferente (` >  `). Se usa cuando el shell detecta que el comando no ha terminado (por ejemplo, una comilla abierta) y pide m치s input.

4.  **`void handle_msx_exit(void)`**:

      * Esta funci칩n se llama justo antes de cerrar el shell.
      * **`isatty(FILENO)`**: Comprueba si la entrada y la salida son una terminal real.
      * **`write(1, "exit\n", 5)`**:
          * Bash y otros shells imprimen "exit" cuando sales con `Ctrl+D` o el comando `exit`.
          * **Importante:** Solo imprimimos esto si estamos en modo interactivo (`isatty`). [cite\_start]Si tu shell est치 ejecutando un script o recibiendo datos por un pipe, no debe "ensuciar" la salida con la palabra "exit"[cite: 31].

-----

춰Ya tenemos la cara del shell\! 游땎
Pero si intentas ejecutarlo ahora, todav칤a no ver치s nada porque el `main` no llama a estas funciones y no tenemos el bucle que las usa.
