Llegamos al momento crucial: el **bucle de vida** del programa. Hasta ahora tenemos piezas sueltas (parser, ui, limpieza), pero nos falta el motor que las haga girar indefinidamente.

Empezaremos por **2.4.1. Bucle principal interactivo (`run_tty_loop`)**.

Para que estos archivos se "hablen" entre s칤, primero necesitamos su archivo de cabecera (header).

### **Paso A: El Contrato (`includes/loop.h`)**

Crea el archivo `includes/loop.h`. Este definir치 las funciones que arrancan los bucles.

Copia este c칩digo:

```c
#ifndef LOOP_H
# define LOOP_H

# include "minishell.h"

void	run_non_tty_loop(t_shell *sh);
void	run_tty_loop(t_shell *sh);

#endif
```

[cite\_start][cite: 661-662]

-----

### **Paso B: El Bucle Interactivo (`src/loop_tty.c`)**

Este archivo gestiona cuando un **humano** est치 escribiendo en el shell.

Crea el archivo `src/loop_tty.c` y a침ade el siguiente c칩digo:

```c
#include "loop.h"
#include "loop_io.h"
#include "minishell.h"

/* Funci칩n auxiliar para leer y gestionar EOF (Ctrl+D) */
static char	*read_tty_logical(t_shell *sh)
{
	char	*line;

	(void)sh;
	line = read_msx_line();
	if (!line)
	{
		handle_msx_exit();
		return (NULL);
	}
	return (line);
}

/* El bucle infinito interactivo */
void	run_tty_loop(t_shell *sh)
{
	char	*logical;

	while (sh->running)
	{
		logical = read_tty_logical(sh);
		if (!logical)
			break ;
		sh->current_line = logical;
		process_line(logical, sh, 1);
		free(logical);
		sh->current_line = NULL;
	}
	if (sh->current_pipeline)
	{
		/* Pendiente Fase 6: Limpieza profunda del pipeline
		free_pipeline(sh->current_pipeline);
		free(sh->current_pipeline);
		*/
		sh->current_pipeline = NULL;
	}
}
```

[cite\_start][cite: 53-55]

#### **游댌 Explicaci칩n detallada l칤nea a l칤nea:**

1.  **`static char *read_tty_logical(t_shell *sh)`**:

      * Es una capa de seguridad sobre `read_msx_line` (que creamos en 2.1).
      * **`line = read_msx_line();`**: Llama a `readline` y muestra el prompt "MSX\>".
      * **`if (!line)`**: Si `readline` devuelve `NULL`, significa que el usuario puls칩 `Ctrl+D` (EOF - End Of File) o se cerr칩 la entrada.
      * **`handle_msx_exit();`**: Si es EOF, imprimimos "exit" en la pantalla (como hace bash) para ser educados.
      * Devuelve `NULL` para indicar que debemos romper el bucle.

2.  **`void run_tty_loop(t_shell *sh)`**:

      * **`while (sh->running)`**: Este es el coraz칩n del programa. Se repetir치 infinitamente hasta que `sh->running` sea 0 (por ejemplo, si se ejecuta el comando `exit`).
      * **`logical = read_tty_logical(sh);`**: Esperamos a que el usuario escriba algo. El programa se "congela" aqu칤 esperando input.
      * **`if (!logical) break;`**: Si recibimos `Ctrl+D`, rompemos el bucle y el programa terminar치.
      * **`sh->current_line = logical;`**: Guardamos la l칤nea en nuestra estructura global. Esto es vital para la gesti칩n de errores o se침ales (si hay que limpiar de emergencia).
      * **`process_line(logical, sh, 1);`**:
          * Enviamos la l칤nea a procesar (separar por `;`, parsear, ejecutar).
          * El `1` final indica `record_history = true`: como es un humano escribiendo, queremos guardar esto en el historial.
      * **`free(logical);`**: Una vez procesada y ejecutada la l칤nea, liberamos la memoria de la cadena de texto para no tener leaks.
      * **Bloque final `if (sh->current_pipeline)`**:
          * Es una limpieza de seguridad extra al salir del bucle. Dejamos comentada la funci칩n `free_pipeline` porque pertenece a la Fase 6, pero preparamos el terreno.

-----

Ya tenemos el comportamiento interactivo definido. Ahora nos falta el "Dispatcher" que decide qu칠 bucle usar y lo conecta con el `main`.