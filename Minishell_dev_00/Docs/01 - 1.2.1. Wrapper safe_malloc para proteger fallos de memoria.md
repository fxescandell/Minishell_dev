Ahora vamos a implementar la primera función dentro de `src/utils/memory_utils.c`.

### **1.2.1. Wrapper `safe_malloc` para proteger fallos de memoria**

**¿Por qué necesitamos esto?**
En C, cada vez que pides memoria con `malloc`, existe una pequeña posibilidad de que el sistema operativo diga "no tengo memoria disponible" y devuelva `NULL`. Si intentas usar ese puntero `NULL` sin comprobarlo, tu programa explotará (Segmentation Fault).

Para no escribir el mismo `if (!ptr)` cientos de veces en tu código, escribimos esta función una sola vez.

Añade el siguiente código a tu archivo `src/utils/memory_utils.c`, justo debajo del include:

```c
void	*safe_malloc(size_t size)
{
	void	*ptr;

	ptr = malloc(size);
	if (!ptr)
	{
		ft_putstr_fd("MSX: malloc: allocation failed\n", 2);
		exit(EXIT_FAILURE);
	}
	return (ptr);
}
```

[cite\_start][cite: 147, 148]

#### **Explicación línea a línea:**

1.  **`void *safe_malloc(size_t size)`**:

      * La función devuelve un puntero genérico (`void *`) para que pueda usarse con cualquier tipo de dato (`int`, `char`, structs, etc.).
      * Recibe `size`, que es la cantidad de bytes que necesitamos.

2.  **`ptr = malloc(size);`**:

      * Llamamos a la función original del sistema para intentar reservar la memoria.

3.  **`if (!ptr)`**:

      * Esta es la comprobación de seguridad. Si `ptr` es `NULL` (0), significa que la reserva falló.

4.  **`ft_putstr_fd("MSX: malloc: allocation failed\n", 2);`**:

      * Si falló, imprimimos un mensaje de error explicativo.
      * **Importante:** Escribimos en el file descriptor **2 (Standard Error)**. Los errores del sistema siempre deben ir por este canal, nunca por el 1 (Standard Output), para no ensuciar posibles redirecciones.

5.  **`exit(EXIT_FAILURE);`**:

      * Terminamos el programa de forma abrupta pero controlada. Si el shell no tiene memoria ni para funcionar, es mejor cerrarlo que dejar que siga ejecutándose de forma inestable.

6.  **`return (ptr);`**:

      * Si llegamos aquí, la memoria es válida y segura. Devolvemos el puntero para que el resto del programa lo use.
