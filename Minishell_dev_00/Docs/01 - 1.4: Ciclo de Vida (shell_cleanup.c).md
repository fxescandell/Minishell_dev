Tienes toda la raz칩n, me adelant칠 preguntando si pas치bamos al 1.5 sin haber concretado el c칩digo del 1.4. Disculpa el salto.

Vamos a implementar el punto **1.4** siguiendo estrictamente nuestro 칤ndice atomizado.

-----
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.




### **1.4. Ciclo de Vida (`src/shell_cleanup.c`)**

**Objetivo:**
Este archivo es el encargado de "apagar la luz" al salir. Un shell robusto debe ser capaz de limpiar toda la memoria que ha reservado y restaurar la configuraci칩n de la terminal, tanto si sale normalmente (`exit`) como si ocurre un error fatal.

Como estamos en la **Fase 1**, todav칤a no hemos creado las funciones para liberar el entorno (`free_env`) ni los pipelines (`free_pipeline`). Para que el c칩digo compile ahora mismo, implementaremos la estructura completa pero dejaremos comentadas las partes que dependen de archivos futuros.

#### **1.4.1. Estructura inicial de `cleanup_shell`**

Crea el archivo `src/shell_cleanup.c` y copia el siguiente c칩digo:

```c
#include "minishell.h"

static void	clear_runtime_state(t_shell *shell)
{
	if (shell->current_segments)
	{
		free_string_array(shell->current_segments);
		shell->current_segments = NULL;
	}
	if (shell->current_line)
	{
		free(shell->current_line);
		shell->current_line = NULL;
	}
	/* Pendiente para la Fase 6:
	if (shell->current_pipeline)
	{
		free_pipeline(shell->current_pipeline);
		free(shell->current_pipeline);
		shell->current_pipeline = NULL;
	}
	*/
}

static void	clear_environment(t_shell *shell)
{
	if (!shell->envp)
		return ;
	/* Pendiente para la Fase 3:
	free_env(shell->envp);
	*/
	shell->envp = NULL;
}

void	cleanup_child(t_shell *shell)
{
	if (!shell)
		return ;
	clear_runtime_state(shell);
	clear_environment(shell);
}

void	cleanup_shell(t_shell *shell)
{
	if (!shell)
		return ;
	clear_runtime_state(shell);
	clear_environment(shell);
	if (shell->term_saved)
	{
		tcsetattr(STDIN_FILENO, TCSANOW, &shell->term_orig);
		shell->term_saved = 0;
	}
	rl_clear_history();
}
```

[cite\_start][cite: 17-24]

#### **游댌 Explicaci칩n detallada l칤nea a l칤nea:**

1.  **`static void clear_runtime_state(t_shell *shell)`**:

      * Es `static` porque es una funci칩n auxiliar interna, solo visible en este archivo.
      * Su trabajo es limpiar lo que ocurre *durante* la ejecuci칩n de un comando (la l칤nea que el usuario escribi칩 y c칩mo la dividimos).
      * **`free_string_array(shell->current_segments)`**: Usamos la funci칩n que creaste en el punto 1.2.2 para liberar los segmentos de texto (comandos separados por `;`).
      * **`free(shell->current_line)`**: Liberamos la l칤nea cruda que nos dio `readline`.
      * *(Parte comentada)*: Aqu칤 ir치 la liberaci칩n de la estructura `t_pipeline` (los comandos parseados), que veremos en la Fase 6.

2.  **`static void clear_environment(t_shell *shell)`**:

      * Se encarga de liberar la copia de las variables de entorno (`envp`).
      * *(Parte comentada)*: Aqu칤 llamaremos a `free_env` cuando la creemos en la Fase 3. De momento solo ponemos el puntero a `NULL` para evitar usos accidentales.

3.  **`void cleanup_child(t_shell *shell)`**:

      * Esta funci칩n la usar치n los **procesos hijos** (los comandos que ejecutas, como `ls`).
      * Cuando haces `fork`, el hijo tiene una copia de toda la memoria del padre. Antes de que el hijo termine (o si falla al intentar ejecutar un comando), debe liberar esa memoria para que herramientas como *Valgrind* no reporten errores.

4.  **`void cleanup_shell(t_shell *shell)`**:

      * Esta es la funci칩n maestra que llamar치 el `main`.
      * Llama a las dos anteriores para limpiar datos.
      * **`tcsetattr(STDIN_FILENO, TCSANOW, &shell->term_orig)`**:
          * Restaura la configuraci칩n original de la terminal.
          * En la Fase 2 modificaremos la terminal para manejar se침ales (ocultar `^C`). Si salimos del shell sin restaurarla, la terminal del usuario quedar칤a "rara".
      * **`rl_clear_history()`**:
          * Funci칩n espec칤fica de la librer칤a `readline`. Libera la memoria interna que usa para recordar el historial de comandos (flechas arriba/abajo).

-----

Ahora s칤 tenemos el ciclo de vida definido.

쯇odemos pasar al **1.5. Punto de Entrada (`src/main.c`)** para conectar todo esto?