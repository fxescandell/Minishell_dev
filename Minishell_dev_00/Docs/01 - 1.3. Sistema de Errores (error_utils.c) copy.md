Vamos a abordar la **Fase 1.3: Sistema de Errores**, comenzando por la creaci칩n del archivo y la primera funci칩n fundamental.

### **1.3. Sistema de Errores (`src/utils/error_utils.c`)**

**쯇or qu칠 necesitamos este archivo?**
En un shell, los errores son constantes: el usuario escribe mal un comando, intenta abrir un archivo que no existe o falla un permiso.

1.  **Consistencia:** Queremos que todos los errores tengan el mismo formato (ej: `MSX: comando: error`).
2.  **Direccionamiento (File Descriptors):** En Unix, la salida est치ndar (`STDOUT`, descriptor 1) es para los datos 칰tiles (lo que queremos ver o enviar a un pipe). Los errores **siempre** deben ir a la salida de error est치ndar (`STDERR`, descriptor 2). Si mezclamos errores en `STDOUT`, podr칤amos corromper archivos si el usuario usa una redirecci칩n (`>`).

Crea el archivo `src/utils/error_utils.c` e incluye la cabecera:

```c
#include "minishell.h"
```

-----

### **1.3.1. Funci칩n `print_error` para mensajes estandarizados**

Esta funci칩n ser치 la encargada de "hablar" con el usuario cuando algo salga mal sin detener el programa.

A침ade el siguiente c칩digo a `src/utils/error_utils.c`:

```c
int	print_error(const char *cmd, const char *msg)
{
	if (cmd && msg)
	{
		ft_putstr_fd("MSX: ", STDERR_FILENO);
		ft_putstr_fd(cmd, STDERR_FILENO);
		ft_putstr_fd(": ", STDERR_FILENO);
		ft_putstr_fd(msg, STDERR_FILENO);
		ft_putstr_fd("\n", STDERR_FILENO);
	}
	else if (cmd)
	{
		ft_putstr_fd("MSX: ", STDERR_FILENO);
		ft_putstr_fd(cmd, STDERR_FILENO);
		ft_putstr_fd("\n", STDERR_FILENO);
	}
	else if (msg)
	{
		ft_putstr_fd("MSX: ", STDERR_FILENO);
		ft_putstr_fd(msg, STDERR_FILENO);
		ft_putstr_fd("\n", STDERR_FILENO);
	}
	else
		ft_putstr_fd("MSX: error\n", STDERR_FILENO);
	return (1);
}
```

[cite\_start][cite: 154-157]

#### **游댌 Explicaci칩n detallada l칤nea a l칤nea:**

1.  **`int print_error(const char *cmd, const char *msg)`**:

      * Recibe dos cadenas: `cmd` (el comando que caus칩 el error, ej: "ls") y `msg` (la descripci칩n, ej: "No such file or directory").
      * Devuelve `int`: Retorna `1`. Esto es un truco muy 칰til. En la shell, el c칩digo de error gen칠rico es 1. Esto nos permitir치 escribir l칤neas como `return (print_error("ls", "error"));` para imprimir y devolver el c칩digo de error en una sola l칤nea.

2.  **`if (cmd && msg)`**:

      * Este es el caso m치s completo. Tenemos tanto el causante como la explicaci칩n.
      * **`ft_putstr_fd("MSX: ", STDERR_FILENO);`**: Escribimos nuestro "prompt" o nombre de shell al principio. Usamos `STDERR_FILENO` (que vale 2) para asegurar que el mensaje se vea en pantalla incluso si el usuario redirige la salida (`ls > archivo`).
      * La secuencia imprime: `MSX: ls: No such file or directory\n`.

3.  **`else if (cmd)`**:

      * Caso donde solo queremos quejarnos de un comando sin dar detalles extra, o el mensaje es el comando mismo.
      * Imprime: `MSX: comando\n`.

4.  **`else if (msg)`**:

      * Caso gen칠rico donde no hay un comando espec칤fico asociado, solo un mensaje de error del sistema.
      * Imprime: `MSX: mensaje de error\n`.

5.  **`else`**:

      * Una red de seguridad. Si nos llaman con ambos par치metros `NULL` (algo que no deber칤a pasar, pero por si acaso), imprimimos un error gen칠rico.

6.  **`return (1);`**:

      * Como mencionamos arriba, devuelve 1. Esto simplificar치 mucho la l칩gica en `main.c` o en el parser cuando detectemos un error y queramos actualizar el `last_status` de la shell.

-----

쯊ienes lista esta funci칩n? Si es as칤, pasamos al punto **1.3.2** para ver c칩mo manejar errores fatales que s칤 deben cerrar el programa.