춰Estupendo\! Vamos a darle vida al archivo principal.

Estamos en el punto **1.5.1. Inicializaci칩n de `t_shell`**.

**Objetivo:**
Antes de hacer nada, necesitamos poner todos los valores de nuestra estructura principal a cero o a un estado conocido. Si no lo hacemos, `shell->running` o `shell->envp` podr칤an contener "basura" de la memoria, causando comportamientos impredecibles.

En `src/main.c`, debajo del include, vamos a a침adir dos funciones est치ticas (privadas):

1.  `init_terminal`: Para guardar la configuraci칩n actual de la terminal.
2.  `init_shell`: La funci칩n que prepara toda la estructura.

Copia este bloque en `src/main.c`:

```c
/* Funci칩n auxiliar para guardar la configuraci칩n de la terminal */
static void	init_terminal(t_shell *shell)
{
	struct termios	term;

	shell->term_saved = 0;
	if (!isatty(STDIN_FILENO))
		return ;
	if (tcgetattr(STDIN_FILENO, &term) == -1)
		return ;
	shell->term_orig = term;
	shell->term_saved = 1;
	
	/* Ocultar caracteres de control (^C, ^\) - Se refinar치 en Fase 2
	   term.c_lflag &= ~ECHOCTL;
	   tcsetattr(STDIN_FILENO, TCSANOW, &term);
	*/
}

/* Funci칩n principal de inicializaci칩n */
static void	init_shell(t_shell *shell, char **envp)
{
	/* extern char	**environ; */ // 칔til si envp es NULL, lo veremos luego.

	if (!shell)
		return ;
	
	// 1. Inicializar entorno (Pendiente Fase 3)
	// shell->envp = duplicate_env(envp);
	(void)envp; // Evitar warning por ahora
	shell->envp = NULL; 

	// 2. Estado inicial
	shell->last_status = 0;
	shell->running = 1;
	
	// 3. Punteros de limpieza a NULL
	shell->current_pipeline = NULL;
	shell->current_line = NULL;
	shell->current_segments = NULL;
	
	// 4. Configurar terminal
	init_terminal(shell);
	
	// 5. Actualizar PWD/SHLVL (Pendiente Fase 8 y 3)
	// update_pwd(shell);
	// update_shell_level(&shell->envp);
}
```

[cite\_start][cite: 37, 38, 39, 40]

#### **游댌 Explicaci칩n detallada l칤nea a l칤nea:**

**Funci칩n `init_terminal`**:

1.  **`isatty(STDIN_FILENO)`**: Verifica si el programa se est치 ejecutando en una terminal real (interactiva) o si le est치n pasando datos por un pipe (ej: `echo "ls" | ./minishell`). [cite\_start]Si no es una terminal, no tocamos la configuraci칩n[cite: 37].
2.  [cite\_start]**`tcgetattr(..., &term)`**: Obtiene la configuraci칩n actual de la terminal (velocidad, flags, etc.)[cite: 37].
3.  **`shell->term_orig = term;`**: Guardamos una copia de seguridad. [cite\_start]Esto es crucial para que `cleanup_shell` (que escribimos en el paso 1.4) pueda dejar la terminal como estaba al salir[cite: 37].

**Funci칩n `init_shell`**:

1.  **`shell->envp = NULL;`**:
      * Aqu칤 es donde normalmente copiar칤amos las variables de entorno (`duplicate_env`). [cite\_start]Como esa funci칩n es de la **Fase 3**, por ahora lo dejamos a `NULL` para que compile[cite: 39].
2.  [cite\_start]**`shell->last_status = 0;`**: El estado de salida inicial (el valor de `$?`) es 0 (칠xito)[cite: 39].
3.  **`shell->running = 1;`**: Nuestro "interruptor" principal. [cite\_start]Mientras esto sea 1, el bucle del shell seguir치 pidiendo comandos[cite: 39].
4.  **Punteros a `NULL`**:
      * `current_pipeline`, `current_line`, etc. Es vital ponerlos a NULL. [cite\_start]Si `free_string_array` (en el cleanup) recibe un puntero no inicializado, intentar치 liberar memoria aleatoria y el programa explotar치[cite: 39].

