### **1.4.1. Estructura inicial de `cleanup_shell` (vac칤a por ahora, pero necesaria)**

**Objetivo:**
Para que nuestro programa compile y enlace correctamente, necesitamos definir las funciones que el `main` va a llamar para limpiarse, aunque todav칤a no tengan toda la l칩gica compleja de liberaci칩n (porque las estructuras como el "pipeline" o el "entorno" a칰n no las hemos creado).

Vamos a crear el archivo y definir el esqueleto de estas funciones.

Crea el archivo `src/shell_cleanup.c` y escribe el siguiente c칩digo inicial:

```c
#include "minishell.h"

static void	clear_runtime_state(t_shell *shell)
{
	// Aqu칤 limpiaremos la l칤nea actual y los comandos parseados.
	// Por ahora solo evitamos warnings de "unused variable".
	if (shell->current_segments)
	{
		free_string_array(shell->current_segments);
		shell->current_segments = NULL;
	}
	// (Pendiente: liberar current_line y current_pipeline en fases futuras)
}

static void	clear_environment(t_shell *shell)
{
	// Aqu칤 liberaremos las variables de entorno.
	// (Pendiente: implementar free_env en Fase 3)
	(void)shell;
}

void	cleanup_child(t_shell *shell)
{
	if (!shell)
		return ;
	clear_runtime_state(shell);
	clear_environment(shell);
}

void	cleanup_shell(t_shell *shell)
{
	if (!shell)
		return ;
	clear_runtime_state(shell);
	clear_environment(shell);
	
	// (Pendiente: restaurar terminal en Fase 2)
	
	rl_clear_history();
}
```

[cite\_start][cite: 17-24]

#### **游댌 Explicaci칩n detallada l칤nea a l칤nea:**

1.  **`static void clear_runtime_state(t_shell *shell)`**:

      * Es una funci칩n auxiliar (`static`) para no exponerla fuera de este archivo.
      * Su trabajo ser치 limpiar lo que ocurre en cada iteraci칩n del bucle (lo que escribes en el prompt).
      * **`free_string_array(shell->current_segments)`**: Como ya tenemos esta herramienta de la fase 1.2.2, la dejamos puesta. Si `current_segments` es NULL, la funci칩n no har치 nada, as칤 que es seguro.

2.  **`static void clear_environment(t_shell *shell)`**:

      * Esta funci칩n se encargar치 de borrar la copia de las variables de entorno (`HOME`, `PATH`...).
      * La dejamos vac칤a `(void)shell` por ahora porque la funci칩n `free_env` pertenece a la **Fase 3**.

3.  **`void cleanup_child(t_shell *shell)`**:

      * Esta funci칩n se llamar치 cuando un proceso hijo (creado con `fork`) termine.
      * Los hijos heredan la memoria del padre. Deben limpiarla antes de salir para que herramientas como Valgrind no reporten falsos positivos de fugas de memoria.

4.  **`void cleanup_shell(t_shell *shell)`**:

      * Es la funci칩n principal que llamar치 el `main` al terminar.
      * Llama a las dos anteriores para limpiar todo.
      * **`rl_clear_history()`**: Es una funci칩n de la librer칤a `readline`. Libera la memoria interna que usa para recordar el historial de comandos (lo que sale al pulsar la flecha arriba).

-----

Con este esqueleto, el compilador estar치 contento cuando llamemos a `cleanup_shell` desde el `main`, aunque por dentro todav칤a haga poco trabajo.

쯇asamos al punto **1.5: Punto de Entrada (`main.c`)**?